# Code Cache Analysis

JIT interprete and compile some methods that are executed frequently,
and these methods are also called HotSpot. After these methods are
compiled into local mode, these codes will be cached and can be
used directly directly the next time they are run, which is the
so-called "code cache". However, like other caches, these code
caches also face problems such as cache hits and cache
invalidation.

## Code cache replacement strategy

Another consideration is the replacement strategy of the code cache.
The size of the cache space is limited. When the remaining free space
in the code cache is not enough to accommodate the native code
generated by the next JIT, you need to consider replacing some of the
existing caches to make room for the new JIT native code . This
management is somewhat similar to page management of virtual memory.
Commonly used algorithms for replacement are:

* Least recently used: The biggest disadvantage of this algorithm is
that it requires a lot of extra overhead to determine which is the
least recently used block

* Clear when it is full: When the cache is full, it will be cleared
immediately, starting from the beginning;

* Preemptively clear: when the cache is not full yet, it will be
cleared

* FIFO: The big advantage of this algorithm is that it takes advantage
of the time locality of the program, because the code that was added
to the cache recently is always the most likely to continue to be used
in the next, and the local code that is added to the cache first may
not be used next. It was used again. There is a variant of this
algorithm called coarse-grained FIFO. It actually divides the entire
cache space into fixed blocks, such as dividing the cache space into
eight blocks. Use these coarse-grained blocks as the basic unit of
replacement

## Code Cache
A code cache system has to solve at least one problem: given a
bytecode instruction, it can find the starting PC of the corresponding
compiled code cache, and jump to execute local code. This problem is
usually solved by using a mapping tableâ€”a table that maintains the
mapping relationship between bytecode and machine code.
